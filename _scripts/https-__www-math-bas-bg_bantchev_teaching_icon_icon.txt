общи операции
-------------
x === y                  сравняване за равенство на какви да е стойности; успява, ако x и y са еднотипни и при това са
                         или равни прости стойности, или една и съща съставна стойност

x ~=== y                 обратното на === сравнение

x := y                   присвояване

x :=: y                  размяна на стойностите на x и y; стойността е тази на x след размяната

x <- y                   условно присвояване

x <-> y                  условна размяна

\ x                      x, ако стойността му не е &null, в противен случай неуспех; резултатът е променлива, ако x е такава

/ x                      x, ако стойността му е &null, в противен случай неуспех; резултатът е променлива, ако x е такава

type(x)                  низ, представящ типа на x

copy(x)                  ако x е съставна стойност – равна на нея друга стойност, иначе самото x



избор
-----
if e₀ then e₁ [ else e₂ ]                 case e of {
                                            e₀₁ : e₁
                                            ...
                                          [ default : e₀₀ ]
                                          }


у-връзки
--------
e₁ & e₂                  „и“ по успех

e₁ | e₂                  „или“ по успех

not e                    обръщане на успех/неуспех (&null при успех)


генератори
----------
e₁ to e₂ [ by e₃ ]       аритметична прогресия с начало e₁, гранична стойност e₂ и стъпка e₃ (подразбира се 1)

seq([i[,j]])             безкрайна аритметична прогресия с начало i и стъпка j; i и j са цели числа, подразбира се 1 за всяко
                                                      
| e                      поражда докато e успява
                                                          
e \ i                    поражда ≤ i стойности
                                                          
! e                      поражда ел-те на стр-на стойност


повтаряне
---------
repeat e                 „винаги“

while e₀ [ do e₁ ]       докато e₀ е успешно

until e₀ [ do e₁ ]       докато e₀ е неуспешно

every g [ do e ]         за всяка стойност от g

break [ e ]              вкл. break next, break break, ...

next


процедури и съпрограми
----------------------
procedure име(параметри) определяне; процедурите не могат да се влагат и всички са глобални
  ...
end

x(а₁,а₂,…)               ако x е процедура или функция, повикване с посочените аргументи; x може да е име или другояче
                         получена процедурна стойност; ако x е цяло число, пресмята се изразът с този пореден номер;
                         прилага се и броенето назад; ако изразът е променлива, и резултатът е такъв

x ! y                    ако x е процедура или функция, повикване с аргументи от списъка y; x може да е име или другояче
                         получена процедурна стойност; ако x е цяло число, дава се стойността на члена на списъка y с този
                         пореден номер; прилага се и броенето назад; ако изразът е променлива, и резултатът е такъв


return [ e ]             завършва с успех (и стойност)

fail                     подразбира се при завършване на процедура!

suspend [x [ do … ]]     съпрограмно връщане на управлението към повикващия, предавайки поредната стойност на генератора x;
                         при възобновяване на изпълнението на текущия процедурен екземпляр частта след do се пресмята преди
                         пресмятането на x за пораждане на следваща стойност; за x се подразбира &null

proc(s[,i])              процедурата, функцията или операцията с име s; i = 1, 2, 3 избира съответно едноместна, двуместна
                         и триместна операция, а i = 0 – вградената функция с име s, дори ако съответното глобално име е
                         получило друга стойност; подразбира се 1

args(p)                  броят параметри на процедурата p; ако той е променлив, дава се отрицателна стойност


списъци (масиви, опашки, стекове, декове)
-----------------------------------------
list([n[,x]])            списък с n члена, равни на x; подразбира се n = 0 и x = &null

[x,y,…]                  списък от посочените членове

x[i]                     член

i ! x                    член

x[i:j]                   изрезка
x[i+:j]                  s[i:i+j]
x[i-:j]                  s[i:i-j]

* x                      размер

? x                      случайно избран член

! x                      изброява x

x ||| y                  слепване

push(x)                  добавяне към началото

get(x) ≡ pop(x)          извличане от началото

put(x)                   добавяне към края

pull(x)                  извличане от края

sort(x[,i])              подреждане, вкл. на разнотипни стойности, по стойността на полетата с индекс i на членовете;
                         подразбира се i = 1


низове
------
"…"                      низ с посоченото съдържание

s[i]                     член

i ! s                    член

s[i:j]                   изрезка
s[i+:j]                  s[i:i+j]
s[i-:j]                  s[i:i-j]

* s                      размер

? s                      случайно избран член

! s                      изброява s

x || y                   слепване

<< <<= >>= >> == ~==     лексикографско сравняване

left(x,n[,y])            низ с дължина n, в който x е отляво, а след него е допълнено отдясно наляво с y

right(x,n[,y])           низ с дължина n, в който x е отдясно, а пред него е допълнено отляво надясно с y

center(x,n[,y])          низ с дължина n, в който x е в средата или малко вляво, а пред и след него е допълнено с y
                         съответно както при right и left

char(n)                  низ с дължина 1 по зададен ASCII код n

ord(s)                   ASCII кода на литерата – единствен член на низа s

repl(s,n)                низ от n повторения на s

reverse(s)               низът, обратен на s

map(s[,s₁,s₂])           низ, получен от s чрез замяна на всяка литера от cset(s)**cset(s₁) със съответната ѝ
                         по място в s₂;  подразбира се замяна на главни с малки букви от латиницата

find(s₁,s₂[,i,j])        редицата от индекси в s₂, които са начало на подниз в рамките на s₂[i:j], равен на s₁

match(s₁,s₂[,i,j])       индексът в s₂ след префикса на s₂[i:j], равен на s₁

any(cs,s[,i,j])          индекс в s на първата литера от множеството cs в рамките на s[i:j];
                         неуспех, ако s[i] не е от cs

many(cs,s[,i,j])         индекс в s на първата литера след тези от множеството cs в рамките на s[i:j];
                         неуспех, ако s[i] не е от cs

upto(cs,s[,i,j])         редицата от индекси в s в рамките на s[i:j], която предхожда
                         първата литера от cs, намираща се в същия отрязък

tab(i)                   дава &subject[&pos:i] и изпълнява &pos := i

move(i)                  дава &subject[&pos:&pos+i] и изпълнява &pos +:= i

trim(s,cs)               низ от съдържанието на s без остатъчните му членове, които са членове и на множеството cs

bal(cs₁,cs₂,cs₃,s[,i,j]) редица от индекси в s на литери в рамките на s[i:j], които са от cs₁ и след които литерите в s[i:j]
                         са уравновесени по отношение на съответствието между cs₂ и cs₃; подразбира се cs₁ = &cset, cs₂ = '('
                         и cs₃ = ')'; употребява се основно за намиране на съответна скоба, включително при влагане

=s                       tab(match(s))


сканиране
---------
s ? x                    пресмятане на x в контекста на низа s – служи за претърсване на низ; когато са част от израза
                         x в операция ?, за множество вградени функции върху низове основният аргумент низ се подразбира
                         да е s; при завършване на операция ?, вложена в друга такава, се възстановяват стойностите на
                         &subject и &pos

s ?:= x                  като s ? x, като накрая резултатът се присвоява на s

&subject                 променлива със стойност претърсваният при пресмятане на израз s?x низ

&pos                     променлива със стойност текущата позиция в &subject при пресмятане на израз s?x
                         промените на &pos под действието на разните функции се отменят при неуспех – използва
                         се за възвратно програмиране

pos(i)                   стойността на &pos, ако |i| = &pos (в противен случай неуспех)


таблици
-------
table([x])               таблица с подразбираща се стойност x (за която се подразбира &null)

t[k]                     член

* t                      размер

? t                      случайно избран член

! t                      изброява t

member(t,k)              k при успех (t има член с ключ k)

insert(t,k,x)            добавя към t стойност x с ключ k, дава t

delete(t,x)              премахва x, дава t

key(t)                   поражда ключовете от t

sort(x[,i])              списък от двойките (списъци от по два члена) ключ-стойност на таблицата x,
                         подредени по ключа (при i = 1) или по стойността (при i = 2); подразбира се i = 1


множества
---------
set(x)                   множество от членовете на списъка x

x ** y                   сечение

x ++ y                   обединение

x -- y                   разлика

* x                      размер

? x                      случайно избран член

! x                      изброява x

member(s,x)              x при успех (x ∈ s)

insert(s,x)              добавя x, дава s

delete(s,x)              премахва x, дава s

sort(x[,i])              списък от членовете на множеството x, подредени, вкл. при разнотипни стойности,
                         по стойността на полетата с индекс i на членовете; подразбира се i = 1


литерни множества
-----------------
cset(x)                  литерно множество от (литерите на) x

'…'                      литерно множество от посочени членове

* x                      размер

? x                      случайно избран член

x ** y                   сечение

x ++ y                   обединение

x -- y                   разлика

~ x                      допълнение 

&cset                    всички литери

&ascii                   128-те литери от множеството ASCII

&digits                  десетте цифри

&letters                 52-те букви от латиницата

&lcase                   малките букви от латиницата

&ucase                   главните букви от латиницата


смеси
-----
record x(y₁,y₂,…)        определение на смес („запис“) с име x и имена на полета изброените в скоби; допуска се само глобално

x(a₁,a₂,…)               образуване на стойност смес от смесения тип с име x и стойности на полетата, както са изброени

x.y                      цитиране на полето y на сместа x

x["y"]                   същото като x.y

x[i]                     цитиране на полето с пореден номер i (цяло число с право или обратно броене)

* x                      брой на полетата на x

? x                      стойността на случайно избрано поле на x

! x                      изброява стойностите на полетата на x


съизрази
--------
create x                 съизраз от израза x

@ x                      резултатът от пресмятането на съизраза x

y @ x                    резултатът от пресмятането на съизраза x с аргумент y (@x от по-горе е съкращение на &null @ x)

^ x                      обновен съизраз от x

* x                      брой породени стойности

&current                 текущо пресмятаният съизраз

&source                  съизразът, повикал текущия съизраз; например @&source е като suspend в процедура

&main                    съизраз, пресмятащ функцията main – все едно, че е породен с @(create main())


вход и изход
------------
read([f])                ред текст, ако има такъв, от файла f; подразбира се &input – стандартният вход

reads([f[,n]])           низ от n или колкото остават литери от файла f; край на ред не се различава от останалите литери;
                         подразбира се f = &input, n = 1

write(а₁,а₂,…)           записване в един или повече файлове с поставяне на литерата край на ред накрая или при преминаване
                         към друг файл; по начало се записва в &output – стандартния изход; ако текущият аргумент е низ,
                         записва се в текущия файл, а ако е файл, той се избира за такъв, в който се записва по-нататък

writes(а₁,а₂,…)          като write(а₁,а₂,…), но без добавяне на литерата край на ред
