<!DOCTYPE html PUBLIC "-//IETF//DTD HTML//EN">
<html><div id="saka-gui-root" style="position: absolute; left: 0px; top: 0px; width: 100%; height: 100%; z-index: 2147483647; opacity: 1; pointer-events: none;"><div><div><style>
@font-face {
  font-family: Roboto; -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased;
  font-style: normal; font-weight: normal; src: url(moz-extension://c902aece-7150-4b89-91ae-a32a5fcde038/Roboto-Regular.tff) format('tff');
}
.saka-hint-body {
  all: initial;
position: absolute;
z-index: 2147483647;
opacity: 1;
font-family: Roboto, sans-serif;
font-weight: 900;
padding: 0.15rem 0.25rem;
border: 0px solid;
text-align: center;
text-decoration: none;
text-transform: uppercase;
vertical-align: middle;
font-size: 12px;
color: #3f51F5;
background-color: #ffffff;
border-color: #ffffff;
box-shadow: 0 3px 1px -2px rgba(0,0,0,.2), 0 2px 2px 0 rgba(0,0,0,.14), 0 1px 5px 0 rgba(0,0,0,.12);
border-radius: 4px;
transform: translate3d(0%, -50%, 0)
}
.saka-hint-normal-char {
  
}
.saka-hint-active-char {
  opacity: 0.5
}</style><div style="position: absolute; left: 0px; top: 0px;"></div></div></div></div><head>
<title>search.cpan.org: The Ultimate CPAN Search</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
</head>
<body fgcolor="#000000" vlink="#aa0000" link="#005555" bgcolor="#ffffff" alink="#006666">

<h1><a name="NAME">НАИМЕНОВАНИЕ

</a></h1><p>perlrequick - Perl regular expressions бърз старт

</p><p></p><hr><h1><a name="DESCRIPTION">ОПИСАНИЕ

</a></h1><p>Тази страница обхваща най-основните неща по създаването и използването на regular expressions ('regexes') в Perl.

</p><pre></pre><p></p><hr><h1><a name="The_Guide">Ръководството

</a></h1><h2><a name="Simple_word_matching">Просто съвпадение на думи

</a></h2><p>Най-простата regex е само дума или, общо казано, низ от символи. Regex, състояща се от
дума, дава съвпадение с всеки низ, който съдържа тази дума:

</p><pre>    "Hello World" =~ /World/;  # съвпадение

</pre><p>В този израз, <code>World</code> е regex и <code>//</code>, ограждащи
<code>/World/</code> казват на perl да претърси низ за съвпадение. Операторът
<code>=~</code> асоциира низът с regex съвпадението и дава за резултат true ако има съвпадение
и false ако не съвпада. В нашият случай, <code>World</code> съвпада с втората дума в
<code>"Hello World"</code>, така че резултатът от сравнението е true. Тази идея има няколко вариации.

</p><p>Изрази като този са полезни в условни преходи:

</p><pre>    print "It matches\n" if "Hello World" =~ /World/;

</pre>
<p>Начинът на съвпадение може да бъде променен, използвайки операторът <code>!~</code>

</p><pre>    print "It doesn't match\n" if "Hello World" !~ /World/;

</pre><p>Символният низ в regex може да бъде заменен от променлива:

</p><pre>    $greeting = "World";
    print "It matches\n" if "Hello World" =~ /$greeting/;

</pre><p>Ако търсите съвпадение в <code>$_</code>, частта <code>$_ =~</code> може да бъде махната:

</p><pre>    $_ = "Hello World";
    print "It matches\n" if /World/;

</pre><p>И на края, разделителите <code>//</code> за съвпадение могат да бъдат сменени с произволни,
слагайки <code>'m'</code> отпред:

</p><pre>    "Hello World" =~ m!World!;   # Съвпада, разделено с '!'
    "Hello World" =~ m{World};   # съвпада, обърнете внимание на '{}'
    "/usr/bin/perl" =~ m"/perl"; # съвпада след '/usr/bin',
                                 # '/' става обикновен символ

</pre><p>Regexes трябва да намери <i>абсолютно точно</i> съвпадение в низа, за да може резултатът
да е true:

</p><pre>    "Hello World" =~ /world/;  # Не съвпада, разлика в главни и малки букви
    "Hello World" =~ /o W/;    # съвпада, ' ' е обикновен символ
    "Hello World" =~ /World /; # не съвпада, няма ' ' в края.

</pre><p>perl винаги връща резултатът от първото намерено съвпадение в низът:

</p><pre>    "Hello World" =~ /o/;       # съвпада с 'o' в 'Hello'
    "That hat is red" =~ /hat/; # съвпада с 'hat' в 'That'

</pre><p>Не всички символи могат да бъдат използвани 'както са' в съвпадението. Някои
символи, наричани <b>метасимволи</b>, са запазени да употреба в regex нотации.
Метасимволите са

</p><pre>    {}[]()^$.|*+?\

</pre><p>Метасимвол може да бъде използван за съвпадение, слагайки отпред обратно наклонена черта:

</p><pre>    "2+2=4" =~ /2+2/;    # не съвпада, + е метасимвол
    "2+2=4" =~ /2\+2/;   # съвпада, \+ се възприема като обикновен +
    'C:\WIN32' =~ /C:\\WIN/;                       # съвпада
    "/usr/bin/perl" =~ /\/usr\/local\/bin\/perl/;  # съвпада

</pre><p>В последната regex, дробната черта <code>'/'</code> също е предходена от обратно наклонена,
защото се използва като разделител в regex.

</p><p>Непечатимите ASCII символи се представят чрез <b>escape последователности</b>.
Общ пример са <code>\t</code> за tab, <code>\n</code> за нов ред и <code>\r</code> за
връщане на каретата. Произволни байтове се представят чрез осмични escape последователности,
например <code>\033</code> или шестнайсетични escape последователности като <code>\x1B</code>:

</p><pre>    "1000\t2000" =~ m(0\t2)        # съвпада
    "cat"        =~ /\143\x61\x74/ # съвпада, но е странен начин да напишеш cat

</pre><p>Regex се възприемат главно като низове, оградени с двойни кавички, така че
замяната с променливи също работи:

</p><pre>    $foo = 'house';
    'cathouse' =~ /cat$foo/;   # съвпада
    'housecat' =~ /${foo}cat/; # съвпада

</pre><p>С всички примери до тук, ако regex намери където и да е съвпадение, тя го приема
за намерено. За да конкретизирате <i>къде</i> точно да го търси трябва да използвате <b>anchor</b>
метасимволите <code>^</code> и <code>$</code>. <code>^</code> означава съвпадение в началото на
низа, а <code>$</code> означава съвпадение в края на низа или преди нов ред в края на низа.
Някои примери:

</p><pre>    "housekeeper" =~ /keeper/;         # съвпада
    "housekeeper" =~ /^keeper/;        # не съвпада
    "housekeeper" =~ /keeper$/;        # съвпада
    "housekeeper\n" =~ /keeper$/;      # съвпада
    "housekeeper" =~ /^housekeeper$/;  # съвпада

</pre><h2><a name="Using_character_classes">Използване на символни класове

</a></h2><p><b>Символният клас</b> позволява търсене на съвпадение на област от възможни
символи вместо единичен символ, в определена позиция.
Символните класове са отделени със скоби <code>[...]</code> набор от символи, които да
бъдат използвани за съвпадение. Ето някои примери:

</p><pre>    /cat/;            # съвпада с 'cat'
    /[bcr]at/;        # съвпада с 'bat', 'cat', или 'rat'
    "abc" =~ /[cab]/; # съвпада с 'a'

</pre><p>В последният израз, въпреки че <code>'c'</code> е първият символ в класа, първата
позиция, където regex открива съвпадение е <code>'a'</code>.

</p><pre>    /[yY][eE][sS]/; # съвпада с 'yes' без значение от главни и малки букви
                    # 'yes', 'Yes', 'YES', и т.н.
    /yes/i;         # също съвпада с 'yes', без значение от главни и малки букви

</pre><p>Последният пример показва съвпадение с използването на <code>'i'</code> <b>модификаторът</b>,
който прави търсенето независимо от главни и малки букви.

</p><p>Символните класове имат също обикновени и специални символи, но наборът от тях в символният
клас е различен от този, извън него. Специалните символи за символните класове са <code>-]\^$</code>
и се използват с escape преди тях:

</p><pre>   /[\]c]def/; # намира ']def' или 'cdef'
   $x = 'bcr';
   /[$x]at/;   # съвпада с 'bat, 'cat', или 'rat'
   /[\$x]at/;  # съвпада с '$at' или 'xat'
   /[\\$x]at/; # съвпада с '\at', 'bat, 'cat', или 'rat'

</pre><p>Специалният символ <code>'-'</code> действа като оператор за обхват в символните класове,
за да може неудобните <code>[0123456789]</code> и <code>[abc...xyz]</code> да станат по-ясните
<code>[0-9]</code> и <code>[a-z]</code>:

</p><pre>    /item[0-9]/;  # намира 'item0' или ... или 'item9'
    /[0-9a-fA-F]/;  # намира шестнайсетична цифра

</pre><p>Ако <code>'-'</code> е първият или последният символ в символен клас, той се възприема като
обикновен символ.

</p><p>Специалният символ <code>^</code> в началото на символен клас става <b>отрицателен символен клас</b>,
който намира съвпадение с всички останали символи, но не и тези, които са в скобите. И двете
<code>[...]</code> и <code>[^...]</code> трябва да намерят съвпадение, иначе се връща резултат false.
От тук 

</p><pre>    /[^a]at/;  # не съвпада с 'aat' или 'at', но съвпада с
               # всички други като 'bat', 'cat, '0at', '%at', и т.н.
    /[^0-9]/;  # съвпада с нечислов символ
    /[a^]at/;  # съвпада с 'aat' или '^at'; тук '^' е обикновен

</pre><p>Perl има някои съкращения за стандартни символни класове:

</p><dl><dt><a name="_d_is_a_digit_and_represents_0_9_"><strong></strong></a><p><a name="_d_is_a_digit_and_represents_0_9_"><strong>*
\d е цифра и замества [0-9]

</strong></a><br><strong>*
\s е празен символ и замества [\ \t\r\n\f]

</strong><br><strong>*
\w е буквен символ (буквено-цифрен или _) и замества [0-9a-zA-Z_]

</strong><br><strong>*
\D е обратното на \d; то замества всеки символ освен цифра [^0-9]

</strong><br><strong>*
\S е обратното на \s; всеки не празен символ [^\s]

</strong><br><strong>*
\W е обратното на \w; то замества всеки не-буквен символ [^\w]

</strong><br><strong>*
Точка '.' съвпада с всеки символ освен "\n"

</strong></p></dt><dd>Съкращенията <code>\d\s\w\D\S\W</code> могат да се използват и в символните класове и
извън тях. Ето някои примери в действие:

<pre>    /\d\d:\d\d:\d\d/; # съвпада с формат за час hh:mm:ss
    /[\d\s]/;         # съвпада с всяка цифра или празен символ
    /\w\W\w/;         # съвпада с буквен символ, следван от не-буква,
                      # следвана от друга буква
    /..rt/;           # съвпада с каквито и да са два символа, следвани от 'rt'
    /end\./;          # съвпада с 'end.'
    /end[.]/;         # същото, съвпада с 'end.'

</pre><p><b>word anchor</b>  <code>\b</code> съвпада с границата между буквен и не-буквен символ.
<code>\w\W</code> или <code>\W\w</code>:

</p><pre>    $x = "Housecat catenates house and cat";
    $x =~ /\bcat/;  # съвпада с cat в 'catenates'
    $x =~ /cat\b/;  # съвпада с cat в 'housecat'
    $x =~ /\bcat\b/;  # съвпада с 'cat' в края на низа

</pre><p>В последният пример, краят на низа се приема за граница между думи.

</p></dd></dl><h2><a name="Matching_this_or_that">Съвпадение на това или онова

</a></h2><p>Можем да търсим съвпадения с различни символни низове с метасимволът за <b>алтернатива</b>
<code>'|'</code>.  За да намерим съпвадение с <code>dog</code> или <code>cat</code>,
ние оформяме regex <code>dog|cat</code>.  Както и преди, perl ще се опита да намери първото
възможно съвпадение с regex. За всеки символ поотделно, perl ще опита да намери първата
алтернатива, <code>dog</code>.  Ако <code>dog</code> не съвпада, perl ще опита следващата
алтернатива, <code>cat</code>.
Ако и <code>cat</code> не съвпада, тогава съвпадението пропада и perl отива на следващата
позиция в низа. Някои примери:

</p><pre>    "cats and dogs" =~ /cat|dog|bird/;  # съвпада с "cat"
    "cats and dogs" =~ /dog|cat|bird/;  # съвпада с "cat"

</pre><p>Въпреки, че <code>dog</code> е първата алтернатива във втората regex, <code>cat</code>
се среща първа в низа.

</p><pre>    "cats"          =~ /c|ca|cat|cats/; # съвпада с "c"
    "cats"          =~ /cats|cat|ca|c/; # съвпада с "cats"

</pre><p>При дадена позиция на символа, първата алтернатива, която позволява на regex
съвпадението да открие съответствие, ще бъде тази която съвпада. По-горе, всички алтернативи
търсят съвпадение в първата позиция на низа, така че първата съвпада.

</p><h2><a name="Grouping_things_and_hierarchical_matching">Групиране на нещата и йерархично съвпадение

</a></h2><p>Метасимволите за <b>групиране</b> <code>()</code> позволяват на част от regex да
бъде възприемана като самостоятелен блок. Частите от regex се групират, като се ограждат със скоби.
Regex <code>house(cat|keeper)</code> означава съвпадение на <code>house</code>, последвано
от <code>cat</code> или <code>keeper</code>. Ето още няколко примера:

</p><pre>    /(a|b)b/;    # съвпада с 'ab' или 'bb'
    /(^a|b)c/;   # съвпада с 'ac' в началото на низа или 'bc' където и да е

</pre><pre>    /house(cat|)/;  # съвпада или с 'housecat' или с 'house'
    /house(cat(s|)|)/;  # съвпада или с  'housecats' или с 'housecat' или с
                        # 'house'.  Както виждате, групите могат да бъдат вмъквани една в друга

</pre><pre>    "20" =~ /(19|20|)\d\d/;  # съвпада с null алтернативата '()\d\d',
                             # понеже '20\d\d' не може да съвпадне

</pre><h2><a name="Extracting_matches">Отделяне чрез съвпадения

</a></h2><p>Метасимволите за групиране <code>()</code> позволяват също и отделяне на
части от низа, които съвпадат. За всяка група, частта която съвпада се предава на специални
променливи <code>$1</code>, <code>$2</code> и т.н. Те могат да се използват както всички
обикновени променливи:

</p><pre>    # Отделя часове, минути, секунди
    $time =~ /(\d\d):(\d\d):(\d\d)/;  # съвпада с форматът hh:mm:ss
    $hours = $1;
    $minutes = $2;
    $seconds = $3;

</pre><p>В списък, съвпадението <code>/regex/</code> с групиране ще върне
списък от съвпадащи стойности <code>($1,$2,...)</code>. Така че можем да го пренапишем като

</p><pre>    ($hours, $minutes, $second) = ($time =~ /(\d\d):(\d\d):(\d\d)/);

</pre><p>Ако има няколко, вмъкнати една в друга групи с regex, <code>$1</code> получава
групата с най-левите отварящи скоби, <code>$2</code> получава следващата група и т.н.
Ето например сложна regex и под нея съвпадащите променливи:

</p><pre>    /(ab(cd|ef)((gi)|j))/;
     1  2      34

</pre><p>Асоциирани със съвпадащите променливи <code>$1</code>, <code>$2</code>, ... са
<b>backreferences</b> <code>\1</code>, <code>\2</code>, ... Backreferences са променливи
за съвпадение, които могат да бъдат използвани <i>вътре</i> в regex:

</p><pre>    /(\w\w\w)\s\1/; # намира последователности като 'the the' в низа

</pre><p><code>$1</code>, <code>$2</code>, ... трябва да бъдат използвани само извън regex, a
<code>\1</code>, <code>\2</code>, ... само вътре в regex.

</p><h2><a name="Matching_repetitions">Повтарящи се съвпадения

</a></h2><p><b>Количествените</b> метасимволи <code>?</code>, <code>*</code>, <code>+</code>, и <code>{}</code>
ни позволяват да определим броя на повторенията на частта от regex, която приемаме за съвпадение.
Те се слагат непосредствено след символът, символният клас, или група, които искаме да укажем.
Имат следните значения:

</p><ul><li><code>a?</code> = съвпада с 'a' 1 или 0 пъти

</li><li><code>a*</code> = съвпада с 'a' 0 или повече пъти, т.е. произволен брой пъти

</li><li><code>a+</code> = съвпада с 'a' 1 или повече пъти, т.е. поне веднъж

</li><li><code>a{n,m}</code> = съвпада поне <code>n</code> пъти, но не повече от <code>m</code>
пъти.

</li><li><code>a{n,}</code> = съвпада поне <code>n</code>  или повече пъти

</li><li><code>a{n}</code> = съвпада точно <code>n</code> пъти

</li></ul><p>Ето някои примери:

</p><pre>    /[a-z]+\s+\d*/;  # съвпада с дума с малки букви, поне няоколко интервала и
                     # произволен брой цифри
    /(\w+)\s+\1/;    # съпада с повтарящи се думи с произволна дължина
    $year =~ /\d{2,4}/;  # проверява дали годината е с размер поне 2 знака, но не повече
                         # от 4 знака
    $year =~ /\d{4}|\d{2}/;    # по-добро съвпадение; отхвърля години с 3 знака

</pre><p>Тези количествени указатели ще опитат да намерят колкото са възможни съвпадения в низът,
докато все още има възможност regex да съвпада. Така че, имаме:

</p><pre>    $x = 'the cat in the hat';
    $x =~ /^(.*)(at)(.*)$/; # съвпада,
                            # $1 = 'the cat in the h'
                            # $2 = 'at'
                            # $3 = ''   (0 съвпадения)

</pre><p>Първият указател <code>.*</code> взема максимално възможното от низът, докато regex
съвпада. За вторият указател <code>.*</code> няма останала част от низа, така че съвпада 0 пъти.

</p><h2><a name="More_matching">Повече съвпадения

</a></h2><p>Има още няоколко неща, които може би искате да научите относно операторите за съвпадение.
В кодът

</p><pre>    $pattern = 'Seuss';
    while (&lt;&gt;) {
        print if /$pattern/;
    }

</pre><p>perl трябва да преизчислява <code>$pattern</code> всеки път, минавайки през цикълът.
Ако <code>$pattern</code> няма да се променя, за да се извърши само веднъж присвояването,
използвайте модификаторът <code>//o</code>. Ако не желаете никакви присвоявания изобщо,
използвайте специалният разделител <code>m''</code>:

</p><pre>    $pattern = 'Seuss';
    m'$pattern'; # съвпада с '$pattern', не 'Seuss'

</pre><p>Глобалният модификатор <code>//g</code> позволява на операторите да търсят съпвадения
из низа колкото е възможно пъти. В скаларни променливи, успешното съвпадение в низът ще кара
<code>//g</code> да преминава от съвпадение на съвпадение, като се пази всяка позиция, където
е намерено съвпадение. Позицията можете да вземете или да установите чрез функцията <code>pos()</code>.
За пример,

</p><pre>    $x = "cat dog house"; # 3 думи
    while ($x =~ /(\w+)/g) {
        print "Word is $1, ends at position ", pos $x, "\n";
    }

</pre><p>извежда

</p><pre>    Word is cat, ends at position 3
    Word is dog, ends at position 7
    Word is house, ends at position 13

</pre><p>Неуспешно съвпадение или промяна на низа в който се търси, нулира позицията.
Ако не искате това да става след всяко неуспешно , добавете <code>//c</code>, както е в
<code>/regex/gc</code>.

</p><p>В списък, <code>//g</code> връща списък от съвпадащи групи или, ако няма такива, списък
от съвпадения за цялата regex. От тук

</p><pre>    @words = ($x =~ /(\w+)/g);  # съвпада
                                # $word[0] = 'cat'
                                # $word[1] = 'dog'
                                # $word[2] = 'house'

</pre><h2><a name="Search_and_replace">Търсене и замяна

</a></h2><p>Търсене и замяна се извършва чрез <code>s/regex/замяна/модификатори</code>.
<code>Замяната</code> е Perl низ, възприеман като ограден с двойни кавички, който заменя в
низът това, което <code>regex</code> открива като съвпадение.
Perl double quoted string that replaces in the
string whatever is matched with the <code>regex</code>.  Операторът <code>=~</code> се
използва и за асоцииране на низ със <code>s///</code>.  Ако се извършва действие с
<code>$_</code>, <code>$_ =~</code> може да не се вписва. Ако има открито съвпадение,
<code>s///</code> връща броя на извършените замяни, а в противен случай връща false.
Ето няколко примера:

</p><pre>    $x = "Time to feed the cat!";
    $x =~ s/cat/hacker/;   # $x съдържа "Time to feed the hacker!"
    $y = "'quoted words'";
    $y =~ s/^'(.*)'$/$1/;  # маха единичните кавички (апострофите),
                           # $y съдържа "quoted words"

</pre><p>С операторът <code>s///</code>, променливите от съвпадението <code>$1</code>,
<code>$2</code>, и т.н. са достъпни веднага, за да се използват като израз за замяна. С
глобалният модификатор <code>s///g</code> ще се извърши търсене и замяна на всички
срещания на regex в низът:

</p><pre>    $x = "I batted 4 for 4";
    $x =~ s/4/four/;   # $x съдържа "I batted four for 4"
    $x = "I batted 4 for 4";
    $x =~ s/4/four/g;  # $x съдържа "I batted four for four"

</pre><p>Модификаторът за изчисление <code>s///e</code> изпълнява <code>eval{...}</code> в
низът за замяна и изчисленият резултат се използва за действителната замяната.
Някои примери:

</p><pre>    # обръщане на всички думи в низ
    $x = "the cat in the hat";
    $x =~ s/(\w+)/reverse $1/ge;   # $x съдържа "eht tac ni eht tah"

</pre><pre>    # превръща проценти в десетичен вид
    $x = "A 39% hit rate";
    $x =~ s!(\d+)%!$1/100!e;       # $x съдържа "A 0.39 hit rate"

</pre><p>В последният пример се вижда, че <code>s///</code> може да използва и други разделители,
като <code>s!!!</code> и <code>s{}{}</code>, а даже и <code>s{}//</code>. Ако се използват единични
кавички (апострофи) <code>s'''</code>, тогава regex търсенето и замяната ще се възприемат като низове, оградени
с единични кавички (апострофи).

</p><h2><a name="The_split_operator">Операторът split

</a></h2><p><code>split /regex/, string</code> разделя <code>string</code> на списък от поднизове
и го връща като резултат. Regex определя символната последователност, на която ще бъде разделен
низът <code>string</code>. Например, за да разделим низ на отделни думи, можем да използваме

</p><pre>    $x = "Calvin and Hobbes";
    @word = split /\s+/, $x;  # $word[0] = 'Calvin'
                              # $word[1] = 'and'
                              # $word[2] = 'Hobbes'

</pre><p>За да разделим списък от числа, разделен със запетаи, използваме

</p><pre>    $x = "1.618,2.718,   3.142";
    @const = split /,\s*/, $x;  # $const[0] = '1.618'
                                # $const[1] = '2.718'
                                # $const[2] = '3.142'

</pre><p>Ако се ползва празна regex <code>//</code>, то низът се разделя на отделни символи.
Ако regex съдържа групиране, тогава полученият списъкъ също ще съдържа съвпадащите поднизове от
групите.

</p><pre>    $x = "/usr/bin";
    @parts = split m!(/)!, $x;  # $parts[0] = ''
                                # $parts[1] = '/'
                                # $parts[2] = 'usr'
                                # $parts[3] = '/'
                                # $parts[4] = 'bin'

</pre><p>Понеже първият символ от $x съвпада с regex, <code>split</code> добавя
празен първоначален елемент към списъкът.

</p><p></p><hr><h1><a name="BUGS">БЪГОВЕ

</a></h1><p>Няма.

</p><p></p><hr><h1><a name="SEE_ALSO">ВИЖ СЪЩО И

</a></h1><p>This is just a quick start guide.  For a more in-depth tutorial on
regexes, see <b>perlretut</b> and for the reference page, see <b>perlre</b>.

</p><p></p><hr><h1><a name="AUTHOR_AND_COPYRIGHT">AUTHOR AND COPYRIGHT

</a></h1><p>Copyright (c) 2000 Mark Kvale
All rights reserved.

</p><p>This document may be distributed under the same terms as Perl itself.

</p><p>Този документът е преведен от Николай Цветков.

</p><h2><a name="Acknowledgments">Acknowledgments

</a></h2><p>The author would like to thank Mark-Jason Dominus, Tom Christiansen,
Ilya Zakharevich, Brad Hughes, and Mike Giroux for all their helpful
comments.

</p><p></p><hr>
</body></html>